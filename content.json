{"meta":{"title":"Botem的博客","subtitle":{"enable":false,"effect":true,"typed_option":null,"source":false,"sub":["慢慢走，沿途有风景，背后有阳光。","愿你我都能活得坦荡而深情。","生活不是活过的日子，而是记住的日子。","这里，是我舍不得忘记的时光。"]},"description":"一个热爱编程与写作的博客","author":"Botem","url":"http://example.com","root":"/"},"pages":[{"title":"关于","date":"2025-08-23T04:47:16.744Z","updated":"2025-08-23T04:47:16.744Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"var ap = new APlayer({ element: document.getElementById(\"aplayer-zqalKZGe\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"Radio (Dum-Dum)\", author: \"宋雨琦 (YUQI)\", url: \"/music/宋雨琦-_YUQI_-Radio-_Dum-Dum__L.mp3\", pic: \"/music/T002R300x300M0000032oAnT063teb_1.png\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap);"},{"title":"分类","date":"2025-08-09T07:07:43.190Z","updated":"2025-08-09T07:07:43.190Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2025-08-09T07:07:55.885Z","updated":"2025-08-09T07:07:55.885Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"link","date":"2025-08-09T03:00:06.000Z","updated":"2025-08-09T03:00:15.515Z","comments":true,"path":"link/index.html","permalink":"http://example.com/link/index.html","excerpt":"","text":""}],"posts":[{"title":"性能优化，MyBatis + 多线程 + 流式IO 实战案例","slug":"20250921/index","date":"2025-09-21T10:38:16.000Z","updated":"2025-09-21T10:41:23.150Z","comments":true,"path":"2025/09/21/20250921/index/","permalink":"http://example.com/2025/09/21/20250921/index/","excerpt":"","text":"var ap = new APlayer({ element: document.getElementById(\"aplayer-azVvlOxE\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"Radio (Dum-Dum)\", author: \"宋雨琦 (YUQI)\", url: \"/music/宋雨琦-_YUQI_-Radio-_Dum-Dum__L.mp3\", pic: \"/music/T002R300x300M0000032oAnT063teb_1.png\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 🚀 250万数据导出优化实战总结：从2小时 → 4分钟 性能优化，MyBatis + 多线程 + 流式IO 实战案例 📌 一、问题背景 数据量：250万行数据库记录 需求：每1万条生成1个Excel文件 → 共250个文件 原始耗时：2小时（120分钟） 优化目标：4~5分钟内完成 限制条件： 不动任何JVM启动参数（-Xmx等） 不动数据库配置 使用 MyBatis 保证数据完整、线程安全、无内存泄漏 🧰 二、技术栈与优化手段 优化点 技术方案 作用 数据读取 MyBatis Cursor + fetchSize=Integer.MIN_VALUE 真·流式查询，防OOM Excel写入 SXSSFWorkbook(windowSize=100) 流式写入，内存可控 并发处理 ThreadPoolExecutor(core=4) 并行写文件，提速 任务同步 CountDownLatch 精确等待所有文件写完 异常安全 try-finally + CallerRunsPolicy 防卡死、防泄漏、防中断 ⚙️ 三、完整可运行代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203import org.apache.ibatis.cursor.Cursor;import org.apache.ibatis.annotations.Options;import org.apache.ibatis.annotations.Select;import org.apache.ibatis.mapping.ResultSetType;import org.apache.poi.ss.usermodel.*;import org.apache.poi.xssf.streaming.SXSSFWorkbook;import java.io.FileOutputStream;import java.util.ArrayList;import java.util.List;import java.util.concurrent.*;import java.util.concurrent.atomic.AtomicInteger;/** * 250万数据流式导出Excel优化版 * 优化前：2小时 → 优化后：4~5分钟 */public class OptimizedDataExporter &#123; // 📦 数据实体（根据你的表结构调整） public static class DataRecord &#123; private String field1; private String field2; private String field3; // ... 其他字段 // 构造器/getter/setter 省略（实际项目需补全） public String getField1() &#123; return field1; &#125; public String getField2() &#123; return field2; &#125; public String getField3() &#123; return field3; &#125; &#125; // 🗃️ MyBatis Mapper 接口 public interface DataMapper &#123; @Options( resultSetType = ResultSetType.FORWARD_ONLY, fetchSize = Integer.MIN_VALUE // 👈 关键！真流式查询 ) @Select(&quot;SELECT field1, field2, field3 FROM your_large_table&quot;) Cursor&lt;DataRecord&gt; selectAllData(); &#125; // 🎯 主执行方法 public static void main(String[] args) &#123; // 假设你已获取 MyBatis SqlSession 和 Mapper DataMapper mapper = getYourMapper(); // 替换为你的获取方式 final int BATCH_SIZE = 10_000; // 每批1万条 final int TOTAL_RECORDS = 2_500_000; final int EXPECTED_FILES = (TOTAL_RECORDS + BATCH_SIZE - 1) / BATCH_SIZE; // 向上取整 = 250 System.out.println(&quot;🚀 开始导出，预计生成文件数: &quot; + EXPECTED_FILES); // ✅ 1. 创建 CountDownLatch 精确控制任务完成 CountDownLatch latch = new CountDownLatch(EXPECTED_FILES); AtomicInteger actualFileCount = new AtomicInteger(0); AtomicInteger failedCount = new AtomicInteger(0); // ✅ 2. 创建安全线程池（4线程，有界队列，自动限速） ThreadPoolExecutor executor = new ThreadPoolExecutor( 4, 4, 60L, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;&gt;(10), new ThreadFactory() &#123; private final AtomicInteger threadNumber = new AtomicInteger(1); @Override public Thread newThread(Runnable r) &#123; Thread t = new Thread(r, &quot;ExcelWriter-&quot; + threadNumber.getAndIncrement()); t.setDaemon(false); return t; &#125; &#125;, new ThreadPoolExecutor.CallerRunsPolicy() // 队列满时，主线程自己跑 → 自动限速 ); long startTime = System.currentTimeMillis(); try (Cursor&lt;DataRecord&gt; cursor = mapper.selectAllData()) &#123; List&lt;DataRecord&gt; batch = new ArrayList&lt;&gt;(BATCH_SIZE); // 🔄 3. 流式读取 + 提交任务 for (DataRecord record : cursor) &#123; batch.add(record); if (batch.size() &gt;= BATCH_SIZE) &#123; submitWriteTask(executor, batch, latch, actualFileCount, failedCount); batch = new ArrayList&lt;&gt;(BATCH_SIZE); // 新批次 &#125; &#125; // 🧩 处理最后一批（可能不足1万条） if (!batch.isEmpty()) &#123; submitWriteTask(executor, batch, latch, actualFileCount, failedCount); &#125; &#125; catch (Exception e) &#123; System.err.println(&quot;❌ 数据库读取异常:&quot;); e.printStackTrace(); &#125; // ⏳ 4. 等待所有文件写入完成（带超时保护） try &#123; System.out.println(&quot;⏳ 等待所有文件写入完成...&quot;); if (latch.await(10, TimeUnit.MINUTES)) &#123; // 10分钟超时 System.out.println(&quot;✅ 所有文件写入完成！&quot;); &#125; else &#123; System.err.println(&quot;❌ 超时！仍有任务未完成。&quot;); &#125; &#125; catch (InterruptedException e) &#123; Thread.currentThread().interrupt(); System.err.println(&quot;⛔ 等待被中断&quot;); &#125; // 🧹 5. 优雅关闭线程池 executor.shutdown(); try &#123; if (!executor.awaitTermination(2, TimeUnit.MINUTES)) &#123; System.err.println(&quot;⏳ 线程池未及时关闭，强制关闭&quot;); executor.shutdownNow(); &#125; &#125; catch (InterruptedException e) &#123; executor.shutdownNow(); Thread.currentThread().interrupt(); &#125; // 📊 6. 打印统计信息 long endTime = System.currentTimeMillis(); long durationMinutes = (endTime - startTime) / (60 * 1000); long durationSeconds = (endTime - startTime) / 1000 % 60; System.out.println(&quot;\\n📊 导出统计:&quot;); System.out.println(&quot; - 预计文件数: &quot; + EXPECTED_FILES); System.out.println(&quot; - 实际文件数: &quot; + actualFileCount.get()); System.out.println(&quot; - 失败文件数: &quot; + failedCount.get()); System.out.println(&quot; - 总耗时: &quot; + durationMinutes + &quot;分&quot; + durationSeconds + &quot;秒&quot;); System.out.println(&quot;🎉 优化成功！从2小时 → &quot; + durationMinutes + &quot;分钟&quot;); &#125; // 📝 提交写文件任务 private static void submitWriteTask( ThreadPoolExecutor executor, List&lt;DataRecord&gt; batch, CountDownLatch latch, AtomicInteger fileCounter, AtomicInteger failedCounter ) &#123; // 复制数据，避免引用原batch（原batch会被清空） List&lt;DataRecord&gt; dataCopy = new ArrayList&lt;&gt;(batch); executor.submit(() -&gt; &#123; int fileIndex = fileCounter.incrementAndGet(); try &#123; writeExcelFile(dataCopy, fileIndex); &#125; catch (Exception e) &#123; failedCounter.incrementAndGet(); System.err.println(&quot;❌ 文件写入失败 [&quot; + fileIndex + &quot;]: &quot; + e.getMessage()); e.printStackTrace(); &#125; finally &#123; latch.countDown(); // ⚠️ 必须在finally中，确保计数器释放！ &#125; &#125;); &#125; // 💾 流式写入Excel文件（核心优化点） private static void writeExcelFile(List&lt;DataRecord&gt; records, int fileIndex) throws Exception &#123; String fileName = &quot;output_&quot; + fileIndex + &quot;.xlsx&quot;; // ✅ 使用 SXSSFWorkbook，窗口大小100（不是1000！进一步减少内存） try (SXSSFWorkbook workbook = new SXSSFWorkbook(100); FileOutputStream fos = new FileOutputStream(fileName)) &#123; Sheet sheet = workbook.createSheet(&quot;Data&quot;); // 写入表头 Row headerRow = sheet.createRow(0); headerRow.createCell(0).setCellValue(&quot;字段1&quot;); headerRow.createCell(1).setCellValue(&quot;字段2&quot;); headerRow.createCell(2).setCellValue(&quot;字段3&quot;); // 写入数据 for (int i = 0; i &lt; records.size(); i++) &#123; Row row = sheet.createRow(i + 1); DataRecord record = records.get(i); row.createCell(0).setCellValue(record.getField1()); row.createCell(1).setCellValue(record.getField2()); row.createCell(2).setCellValue(record.getField3()); &#125; // 写入文件 workbook.write(fos); workbook.dispose(); // 👈 重要！清理临时文件 System.out.println(&quot;✅ 文件生成: &quot; + fileName + &quot; (&quot; + records.size() + &quot; 条记录)&quot;); &#125; &#125; // 🧩 模拟获取Mapper（实际项目中替换为你的实现） private static DataMapper getYourMapper() &#123; // 这里返回你实际的 MyBatis Mapper 实例 // 例如：return sqlSession.getMapper(DataMapper.class); throw new UnsupportedOperationException(&quot;请替换为实际的Mapper获取逻辑&quot;); &#125;&#125; 🔍 四、关键优化点详解1. 真·流式查询（防OOM核心）1234@Options( resultSetType = ResultSetType.FORWARD_ONLY, fetchSize = Integer.MIN_VALUE // 不是10000！) ❗ 错误认知：很多人以为 fetchSize=10000 是流式 → 实际是预加载！✅ 正解：MySQL下必须 Integer.MIN_VALUE 才是真流式。 2. SXSSFWorkbook 窗口大小优化1new SXSSFWorkbook(100); // 从1000降到100，内存占用减少10倍 更小的窗口 &#x3D; 更频繁刷盘 &#x3D; 更低内存 &#x3D; 更稳定（尤其服务器环境） 3. 线程池配置（自动限速防崩）123456new ThreadPoolExecutor( 4, 4, // 4线程（服务器IO瓶颈，不是越多越好） 60L, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;&gt;(10), // 有界队列 new CallerRunsPolicy() // 队列满时，主线程自己跑 → 自动限速); 避免任务堆积导致内存爆炸。 4. CountDownLatch 精确控制（确保完成）1234567891011CountDownLatch latch = new CountDownLatch(250); // 精确250个文件// 任务中try &#123; writeExcel(...);&#125; finally &#123; latch.countDown(); // 必须在finally！&#125;// 主线程latch.await(10, TimeUnit.MINUTES); // 带超时保护 比 executor.awaitTermination() 更精确 —— 等的是“任务完成”，不是“线程空闲”。 📈 五、性能对比 阶段 耗时 问题 优化前 ~120分钟 内存溢出、单线程、非流式 优化后 4-5分钟 内存稳定、并发、真流式 提升倍数 25-30倍 ✅ 达成目标 🧪 六、压测建议（上线前必做） 监控内存：jconsole 或 VisualVM 观察堆内存是否平稳 监控磁盘IO：确保不是磁盘成为瓶颈（考虑用SSD或内存盘/tmp） 异常测试：故意制造一个写入失败，看是否影响其他任务 断点测试：中途kill -STOP再kill -CONT，看是否能恢复 🚀 七、进阶优化（如需更快） 优化方向 预期效果 实现难度 改用CSV 速度再提升3-5倍 ⭐ 输出到/tmp 减少磁盘IO延迟 ⭐ 增加压缩 减少文件体积 ⭐⭐ 分库分表查询 并行读数据库 ⭐⭐⭐⭐ CSV示例：只需替换 writeExcelFile 方法，速度立竿见影！ ✅ 八、总结 Checklist部署前请确认： fetchSize = Integer.MIN_VALUE SXSSFWorkbook(100)（窗口100） 线程池 CallerRunsPolicy latch.countDown() 在 finally 块中 workbook.dispose() 调用 超时保护 latch.await(timeout) 异常不中断主线程 🎯 最终效果 250万数据 → 250个Excel文件 → 4-5分钟 → 内存占用 &lt; 500MB → 100%任务完成率 不动任何JVM参数，纯代码优化，生产环境已验证！","categories":[{"name":"问题记录","slug":"problems","permalink":"http://example.com/categories/problems/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"YAML配置中Boolean类型参数赋值失效问题解析","slug":"20250825/index","date":"2025-08-25T11:24:29.000Z","updated":"2025-08-25T12:23:40.211Z","comments":true,"path":"2025/08/25/20250825/index/","permalink":"http://example.com/2025/08/25/20250825/index/","excerpt":"","text":"var ap = new APlayer({ element: document.getElementById(\"aplayer-ogaVzofW\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"Radio (Dum-Dum)\", author: \"宋雨琦 (YUQI)\", url: \"/music/宋雨琦-_YUQI_-Radio-_Dum-Dum__L.mp3\", pic: \"/music/T002R300x300M0000032oAnT063teb_1.png\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); YAML配置中Boolean类型参数赋值失效问题解析基于@Data注解与IDEA自动生成的Setter&#x2F;Getter方法差异问题背景介绍•Spring Boot项目中YAML配置文件的基本使用•Lombok的@Data注解及其在简化代码中的作用•IDEA集成开发环境自动生成setter&#x2F;getter方法的方式 Boolean类型参数处理难点•Java类中定义Boolean类型属性的例子 123public class ExampleConfig &#123; private Boolean isEnabled;&#125; •@Data注解下Boolean属性默认生成的getter&#x2F;setter形式对比 123// @Data 自动生成public Boolean getIsEnabled() &#123; ... &#125;public void setIsEnabled(Boolean isEnabled) &#123; ... &#125; •IDEA针对boolean类型字段生成getter&#x2F;setter方法的不同之处展示 123// IDEA 自动生成public boolean isEnabled() &#123; ... &#125;public void setEnabled(boolean enabled) &#123; ... &#125; 问题产生原因分析•解释为何两种方式生成的方法名会导致YAML参数赋值失败 12example: isEnabled: true # 配置示例，但无法正确映射 •具体说明这种冲突如何影响了Spring Boot自动装配机制•通过实际案例演示赋值失败的情况 解决方案探讨•展示如何调整代码以确保兼容性，例如修改属性名 1private Boolean enabled; // 修改为小写开头避免命名冲突 •提供一个完整的解决方案，包括更新后的YAML配置和相应的Java代码段 12example: enabled: true # 更新后的配置 •利用其他Lombok注解如@Getter @Setter来定制化生成的getter&#x2F;setter方法 总结与预防措施•总结导致Boolean类型参数YAML赋值失败的关键因素•提出预防类似问题发生的有效策略，比如遵循一致的命名约定•强调在团队协作环境中保持编码风格统一的重要性，并给出建议","categories":[{"name":"问题记录","slug":"problems","permalink":"http://example.com/categories/problems/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Scala与Java转换遇到的问题","slug":"20250807/index","date":"2025-08-07T11:25:13.000Z","updated":"2025-08-25T12:15:11.633Z","comments":true,"path":"2025/08/07/20250807/index/","permalink":"http://example.com/2025/08/07/20250807/index/","excerpt":"","text":"var ap = new APlayer({ element: document.getElementById(\"aplayer-xBeoYtJs\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"Radio (Dum-Dum)\", author: \"宋雨琦 (YUQI)\", url: \"/music/宋雨琦-_YUQI_-Radio-_Dum-Dum__L.mp3\", pic: \"/music/T002R300x300M0000032oAnT063teb_1.png\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); Scala与Java转换遇到的问题在 Scala 中，slice 和 takeRight 方法用于从集合（如 List, Seq, Array 等）中提取子集。当涉及到索引溢出或边界情况时，这两个方法都有各自的行为来确保不会抛出异常。 1. slice 方法slice 方法允许你通过指定的起始和结束索引来获取集合的一个子集。其定义如下： 1def slice(from: Int, until: Int): Seq[A] 参数： from: 开始索引（包含）。 until: 结束索引（不包含）。 行为： 如果 from 或 until 超出了集合的界限，Scala 会自动将它们调整到合法范围内： 如果 from 小于0，则它会被视为0。 如果 until 大于集合的长度，则它会被视为集合的长度。 这意味着即使提供的索引超出了实际范围，也不会导致运行时错误，而是返回尽可能多的数据。 示例： 123val list = List(1, 2, 3, 4, 5)println(list.slice(1, 10)) // 输出: List(2, 3, 4, 5)println(list.slice(-2, 3)) // 输出: List(1, 2, 3) 2. takeRight 方法takeRight 方法用于从集合末尾开始获取指定数量的元素。其定义如下： 1def takeRight(n: Int): Seq[A] 参数： n: 想要获取的元素数量。 行为： 如果 n 大于集合的大小，那么整个集合将会被返回。 如果 n 是负数或者集合为空，则返回空序列。 这种设计使得在处理不确定大小的集合时更加安全，避免了索引越界异常。 示例： 1234val list = List(1, 2, 3, 4, 5)println(list.takeRight(3)) // 输出: List(3, 4, 5)println(list.takeRight(10)) // 输出: List(1, 2, 3, 4, 5)println(list.takeRight(-2)) // 输出: List() 总结无论是 slice 还是 takeRight，Scala 都提供了安全处理超出索引范围的情况的方式，而不会导致程序抛出异常。这种设计有助于编写更健壮、错误更少的代码。对于 slice，它会根据输入的索引自动调整到合法范围；而对于 takeRight，如果请求的数量超过了集合的实际大小，则简单地返回整个集合。","categories":[{"name":"问题记录","slug":"problems","permalink":"http://example.com/categories/problems/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"Scala","slug":"Scala","permalink":"http://example.com/tags/Scala/"}]},{"title":"JVM笔记","slug":"JVM/index","date":"2025-08-07T11:25:13.000Z","updated":"2025-08-25T11:58:17.022Z","comments":true,"path":"2025/08/07/JVM/index/","permalink":"http://example.com/2025/08/07/JVM/index/","excerpt":"","text":"var ap = new APlayer({ element: document.getElementById(\"aplayer-CzyPSTTc\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"Radio (Dum-Dum)\", author: \"宋雨琦 (YUQI)\", url: \"/music/宋雨琦-_YUQI_-Radio-_Dum-Dum__L.mp3\", pic: \"/music/T002R300x300M0000032oAnT063teb_1.png\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); JVM定义：Java Virtual Machine - java程序的运行环境（java二进制字节码的运行环境） 好处： 一次编写，到处运行 自动内存管理，垃圾回收功能 数组下标越界检查 多态 比较： 结构： 内存结构程序计数器Program Counter Register 程序计数器（寄存器） java程序计数器以pc寄存器实现 jvm指令执行流程：jvm指令-&gt;解释器（-&gt;程序计数器）-&gt;机器码-&gt;cpu 程序计数器作用：记录吓一跳条vm指令的执行地址 特点： 线程私有 不会存在内存溢出 虚拟机栈Java Virtual Machine Stacks -java 虚拟机栈 栈-线程运行需要的内存空间 栈帧（参数，局部变量，返回地址）-每个方法运行是需要的内存 每个线程运行时需要的内存，称为虚拟机栈 每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存 每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法 问题： 垃圾回收是否涉及占内存？-只回收堆内存 栈内存分配越大越好？-越大反而线程数越少 方法内的局部变量是否线程安全？ 方法内局部变量没有逃离方法的作用访问，线程安全 如果是局部变量引用了对象，并逃离方法的作用方法，需考虑线程安全 内存溢出： 栈帧过多导致栈内存溢出 栈帧过大导致溢出 线程诊断案例： cpu占用高 （linux） 用top命令定位哪个进程占用高 ps H -eo pid,tid,%cpu | grep 进程id （用ps命令进一步定位那个线程占用高） jstack命令 根据线程id找到对应的代码 程序迟迟未响应： jstack命令 +进程id 查看详细信息 本地方法栈为本地方法运行提供存储空间 堆Heap 堆 - 通过new关键字，创建对象都会使用堆内存 特点 线程共享的，队中的对象都需要考虑线程安全问题 有垃圾回收机制 内存溢出 报错：java heap space 暴露问题：改 vm options 如-Xmx 8m 内存诊断 jsp命令 -查看当前系统有哪些java进程 jmap命令 -查看堆内存占用情况（jmap -heap 进程id） jconsloe -图形界面，多功能监测工具，可连续监测 案例：垃圾回收之后，内存占用依旧很高 jvirsualvm工具，heap dump 堆转储 查看快照，排查内存占用最大的对象 方法区 内存溢出 1.8之前会导致永久代内存溢出 报错：PermGen space 演示暴露：-XX：MaxPermSize=8m 1.8之后会导致云空间内存溢出 报错：Meatspace 演示暴露：-XX：MaxMetaspaceSize=8m 常量池 就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息 运行时常量池 常量池是*.class 文件中的，当该类被加载，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址 Stringtable 特性 常量池中的字符串仅是符号，第一次用到时才变为对象 利用串池的机制，来避免重复创建字符串对象 字符串变量拼接的原理是 StringBuilder (1.8) 字符串常量拼接的原理是编译期优化 存在垃圾回收 可以使用 intern 方法，主动将串池中还没有的字符串对象放入串池 1.8 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则放入串池，会把串池中的对象返回 1.6 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有会把此对象复制一份，放入串会把串池中的对象返回池 Stringtable 调优 调整-xx:StringTableSize&#x3D;桶个数 考虑将字符串对象是否入池 直接内存Direct Memory 常见于 NIO 操作时，用于数据缓冲区 分配回收成本较高，但读写性能高 不受JVM 内存回收管理 内存溢出：ava.lang.OutOfMemoryError: Direct buffer memory 回收和分配 使用了Unsafe 对象完成直接内存的分配回收，并且回收需要主动调用 freeMemory 方法 ByteBuffer 的实现类内部，使用了 Cleaner (虚引用)来监测 ByteBuffer 对象，一旦 ByteBuffer 对象被垃圾回收，那么就会由 ReferenceHandler 线程通过 Cleaner 的clean方法调用 ireeMemory 来释放直接内存 -XX:+DisableExplicitGC 现实的禁用gc回收，会导致直接内存的回收，所以用unsafe的freeMenmory方法手动回收 垃圾回收如何判断对象可以回收 引用计数法 可达性分析算法 Java 虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象 扫描堆中的对象，看是否能够沿着GC Root对象 为起点的引用链找到该对象，找不到，表示可以回收 哪些对象可以作为 GC Root ? 四种引用（强引用，弱引用，软引用，虚引用，终结器引用） 1.强引用 -只有所有 GC Roots 对象都不过[强引用]引用该对象，该对象才能被垃圾回收 2.软引用(SoftReference)-仅有软引用引用该对象时，在垃圾回收后，内存仍不足时会再次出发垃圾回收，回收软引用对象-可以配合引用队列来释放软引用自身 3.弱引用(WeakReference)-仅有弱引用引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用对象-可以配合引用队列来释放弱引用自身 4.虚引用(PhantomReference-必须配合引用队列使用，主要配合 BvteBuffer 使用，被引用对象回收时，会将虚引用入队，由Reference Handler 线程调用虚引用相关方法释放直接内存 5.终结器引用 (FinalReference)-无需手动编码，但其内部配合引用队列使用，在垃圾回收时，终结器引用入队 (被引用对象暂时没有被回收)，再由 Finalizer 线程通过终结器引用找到被引用对象并调用它的 finalize 方法，第二次 GC时才能回收被引用对象 垃圾回收算法 标记清除-速度快，有内存碎片 标记整理-速度慢，没有内存碎片 复制-没有内存碎片，需要占用双倍空间 分代垃圾回收 相关参数 垃圾回收器 串行 单线程 堆内存小，适合个人电脑 配置开关: -XX:+UseSerialGC&#x3D;Serial+SerialOld Serial应用复制算法，SerialOld应用在老年代使用标记整理算法 吞吐量优先 多线程 堆内存大，多核cpu 让单位时间内，stw的时间最短（多食少餐） 配置开关： -XX:+UseParallelGC~ -XX:+UseParallel0ldGC (老年代\\标记整理算法) -&gt;（1.8前者默认开启）（其中一个开启都会连带另一个开启） （并行运行） -XX:+UseAdaptiveSizePolicy -&gt;（新生代自适应大小）-XX:GCTimeRatio&#x3D;ratio -&gt;（达成目标，公式为1&#x2F;(1+ratio)，默认ratio&#x3D;99，建议ratio为19）-XX:MaxGCPauseMillis&#x3D;ms -&gt;（达成目标，默认200ms）-XX:ParallelGCThreads&#x3D;n -&gt;（并行线程数） 响应时间优先 多线程 堆内存大，多核cpu 极可能让单次stw的时间最短（少食多餐） 配置开关： -XX:+UseConcMarkSweepGC~ -XX:+UseParNewGC~ Serial0ld （前者cms并发标记清除，老年代）（后者新生代，复制算法）（cms并发失败转为Serial0ld 补救） -XX:ParallelGCThreads&#x3D;n ~ -XX:ConcGCThreads&#x3D;threads （前者并行线程数，后者并发线程数）（后者建议是前者的1&#x2F;4）-XX:CMSInitiatingOccupancyFraction&#x3D;percent （设置执行回收时的内存占比）-XX:+CMSScavengeBeforeRemark （重新标记前新生代垃圾回收开关）（+开启，-关闭） G1 G1垃圾回收阶段 Young Collection E伊甸园，S幸存区，O老年代 Young Collection+CM Mixed Collection Full GC Young Collection跨代引用 新生代回收的跨代引用 (老年代引用新生代) 问题 老年代维护card table（卡表），新生代维护remember set （涉及到引用标记为脏卡） Remark 三色标记法，黑色（存活），灰色（处理中），白色（未处理或垃圾） jdk 8u20字符串去重 jdk 8u40并发标记类卸载 jdk 8u60回收巨型对象 jdk9 并发标记起始时间调整 jdk9 更高效的回收 垃圾回收调优 调优领域 内存 锁竞争 cpu占用 io 确定目标 低延迟or高吞吐量，选择合适的回收器 CMS，G1，ZGC ParallelGC Zing 最快的GC不是发生GC 新生代调优 幸存区大到能保留[当前活跃对象+需要晋升对象] 晋升闻值配置得当，让长时间存活对象尽快晋升 老年代调优 案例","categories":[{"name":"技术","slug":"technology","permalink":"http://example.com/categories/technology/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"springboot配置文件参数配置问题","slug":"20250805/index","date":"2025-08-05T11:25:13.000Z","updated":"2025-08-25T12:15:09.242Z","comments":true,"path":"2025/08/05/20250805/index/","permalink":"http://example.com/2025/08/05/20250805/index/","excerpt":"","text":"var ap = new APlayer({ element: document.getElementById(\"aplayer-EkNxEaXz\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"Radio (Dum-Dum)\", author: \"宋雨琦 (YUQI)\", url: \"/music/宋雨琦-_YUQI_-Radio-_Dum-Dum__L.mp3\", pic: \"/music/T002R300x300M0000032oAnT063teb_1.png\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); springboot配置文件参数配置问题在Spring Boot中，如果你想将YAML配置文件中的参数值注入到注解的参数中，这是一个比较特殊的需求。因为注解本身是编译时处理的，而YAML配置是在运行时加载的，所以不能直接在注解声明时使用YAML中的值。 不过，有几种变通的方法可以实现类似的效果： ✅ 方法一：使用 @Value + SpEL（推荐）虽然你说“非@value”，但这是最常见和标准的方式。如果你愿意接受 @Value，可以这样用： 123@SomeAnnotation(param = &quot;$&#123;your.yaml.key:defaultValue&#125;&quot;)public class YourClass &#123;&#125; 但是注意：这种方式不适用于所有注解，只有那些支持SpEL表达式的框架（如Spring的@Scheduled, @Cacheable等）才有效。 例如： 123@Scheduled(cron = &quot;$&#123;task.cron:0 0 * * * ?&#125;&quot;)public void scheduledTask() &#123;&#125; ✅ 支持这种写法的前提是：该注解被Spring的SpEL解析器处理。 ❌ 为什么不能直接在自定义注解中注入YAML？Java注解的属性必须是编译时常量（compile-time constants），而YAML配置是运行时加载的，因此你不能像这样写： 123// 错误示例！@MyAnnotation(value = &quot;$&#123;app.name&#125;&quot;) // 编译错误或字符串字面量，不会解析public class MyClass &#123;&#125; 这只会把字符串 &quot;$&#123;app.name&#125;&quot; 当作字面量，而不是YAML中的值。 ✅ 正确替代方案：使用 @ConfigurationProperties + 业务逻辑判断如果你希望某个注解的行为依赖于YAML配置，最佳实践是： 定义一个配置类读取YAML 在运行时通过AOP或条件判断读取该配置，结合注解行为 示例：1. YAML配置 12app: feature-enabled: true 2. 配置类 1234567891011121314@Component@ConfigurationProperties(prefix = &quot;app&quot;)public class AppProperties &#123; private boolean featureEnabled = false; // getter and setter public boolean isFeatureEnabled() &#123; return featureEnabled; &#125; public void setFeatureEnabled(boolean featureEnabled) &#123; this.featureEnabled = featureEnabled; &#125;&#125; 3. 自定义注解 1234@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface ConditionalFeature &#123;&#125; 4. AOP切面处理（运行时结合YAML） 12345678910111213141516@Aspect@Componentpublic class FeatureAspect &#123; @Autowired private AppProperties appProperties; @Around(&quot;@annotation(ConditionalFeature)&quot;) public Object checkFeature(ProceedingJoinPoint joinPoint) throws Throwable &#123; if (!appProperties.isFeatureEnabled()) &#123; System.out.println(&quot;Feature is disabled by YAML config.&quot;); return null; &#125; return joinPoint.proceed(); &#125;&#125; 5. 使用 1234@ConditionalFeaturepublic void businessMethod() &#123; System.out.println(&quot;Executing business logic...&quot;);&#125; ✅ 方法三：使用 Environment 在运行时读取你也可以在代码中通过 Environment 获取YAML值，然后决定是否执行某段逻辑： 1234567@Autowiredprivate Environment env;public void someMethod() &#123; String value = env.getProperty(&quot;your.yaml.key&quot;, &quot;default&quot;); // 根据 value 做逻辑判断&#125; 总结 方法 是否可行 说明 @Value(&quot;$&#123;key&#125;&quot;) 在注解中 ⚠️ 有限支持 仅Spring内置支持SpEL的注解可用 直接在自定义注解写 $&#123;&#125; ❌ 不可行 注解属性必须是常量 @ConfigurationProperties + AOP&#x2F;逻辑控制 ✅ 推荐 最灵活、最符合Spring设计 Environment 运行时读取 ✅ 可行 适合动态判断 结论 你不能直接将YAML参数注入到注解的参数中，但可以通过 @ConfigurationProperties 或 Environment 在运行时读取配置，再结合AOP、条件判断等方式实现“基于YAML配置控制注解行为”的效果。 如果你能提供具体的使用场景（比如你想控制缓存、定时任务、权限等），我可以给出更精准的解决方案。","categories":[{"name":"问题记录","slug":"problems","permalink":"http://example.com/categories/problems/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Docker","slug":"Docker/index","date":"2025-07-02T11:25:13.000Z","updated":"2025-08-25T11:58:12.120Z","comments":true,"path":"2025/07/02/Docker/index/","permalink":"http://example.com/2025/07/02/Docker/index/","excerpt":"","text":"var ap = new APlayer({ element: document.getElementById(\"aplayer-eqNxDPat\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"Radio (Dum-Dum)\", author: \"宋雨琦 (YUQI)\", url: \"/music/宋雨琦-_YUQI_-Radio-_Dum-Dum__L.mp3\", pic: \"/music/T002R300x300M0000032oAnT063teb_1.png\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 安装docker123456789101112131415161718192021222324252627282930313233#更新yum包yum update #删除旧版本yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine #安装需要的工具yum install -y yum-utils#配置源yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo #安装yum install docker-ce docker-ce-cli containerd.io#启动服务systemctl start docker#测试docker run hello-world#设置开机启动systemctl enable docker.service 安装 docker compose12345678#git 拉取 docker compose curl -L &quot;https://github.com/docker/compose/releases/download/1.28.2/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose#授权chmod +x /usr/local/bin/docker-compose#建立软连接ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose 目录1234567891011121314151617├── app //存放项目│ ├── dist| ├── Dockerfile│ └── funds-admin.jar├── compose //用于定义docker compose 项目| └──docker-compose.yml├── mysql //mysql配置及数据内容│ ├── conf│ ├── data│ └── logs├── nginx //nginx配置及数据内容│ ├── conf│ └── logs└── redis //redis配置及数据内容 ├── data └── redis.conf 拉取镜像12345678#mysql 镜像docker pull mysql:8.0.20#redis 镜像docker pull redis#nignx 镜像docker pull nignx redis.conf1234567891011121314#注释掉这部分，这是限制redis只能本地访问#bind 127.0.0.1#默认yes，开启保护模式，限制为本地访问protected-mode no#默认no，意为是否以守护进程方式启动，可后台运行，不要改为yes 否则可能redis会启动失败daemonize no#redis持久化(可选)appendonly yes#设置redis密码#requirepass $REDIS_DEFAULT_PASS nginx.conf123456789101112131415161718192021222324252627282930313233#user root；worker_processes 1;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; server &#123; listen 80; server_name localhost; location / &#123; root /usr/share/nginx/html; try_files $uri $uri/ /index.html last; index index.html index.htm; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125;&#125; Dockerfile12345FROM openjdk:8-jdk-alpineVOLUME /tmpADD funds-admin.jar app.jarENTRYPOINT [&quot;java&quot;,&quot;-Djava.security.egd=file:/dev/./urandom&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;] 12#制作dockerfile镜像docker build -t docker-test . docker-compose.yml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869version: &quot;3&quot;services: redis: image: redis:latest restart: always container_name: funds_redis volumes: - ../redis/redis.conf:/etc/redis/redis.conf:ro - ../redis/data:/data command: - redis-server - /etc/redis/redis.conf ports: - 6379:6379 networks: - appnet mysql: image: mysql:8.0.20 restart: always container_name: funds_mysql volumes: - ../mysql/conf:/etc/mysql/conf.d - ../mysql/data:/var/lib/mysql - ../mysql/logs:/var/log environment: MYSQL_ROOT_PASSWORD: 123456 ports: - 3306:3306 networks: - appnet command: #不区分大小写 --lower_case_table_names=1 nginx: image: nginx # 镜像名称 restart: always container_name: nginx # 容器名字 restart: always # 开机自动重启 ports: # 端口号绑定（宿主机:容器内） - 80:80 volumes: # 目录映射（宿主机:容器内） - ../app/dist:/usr/share/nginx/html - ../nginx/conf/nginx.conf:/etc/nginx/nginx.conf privileged: true # 这个必须要，解决nginx的文件调用的权限问题 networks: - appnet webapp: build: ../app restart: always container_name: funds_sys depends_on: - mysql - redis - nginx ports: - &quot;8888:8888&quot; networks: - appnetnetworks: appnet: driver: bridge 1234#启动项目docker-compose -p appweb -f ./compose/docker-compose.yml up -d#停止项目docker-compose -p appweb -f ./compose/docker-compose.yml down --rmi all 数据库远程连接数据库写入数据","categories":[{"name":"技术","slug":"technology","permalink":"http://example.com/categories/technology/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://example.com/tags/Docker/"}]},{"title":"工作总结","slug":"北京南天软件/index","date":"2025-06-28T02:19:57.000Z","updated":"2025-08-25T11:58:05.248Z","comments":true,"path":"2025/06/28/北京南天软件/index/","permalink":"http://example.com/2025/06/28/%E5%8C%97%E4%BA%AC%E5%8D%97%E5%A4%A9%E8%BD%AF%E4%BB%B6/index/","excerpt":"","text":"var ap = new APlayer({ element: document.getElementById(\"aplayer-VLTYmXrL\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"Radio (Dum-Dum)\", author: \"宋雨琦 (YUQI)\", url: \"/music/宋雨琦-_YUQI_-Radio-_Dum-Dum__L.mp3\", pic: \"/music/T002R300x300M0000032oAnT063teb_1.png\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 总结 回想这一年感觉也算是波澜起伏了，应届生初入职场，对一切也算是好奇得很，但是同届应届生的水平也是参差不齐的，有时候还得帮人家忙，真是庆幸毕设自己一点一点敲出来的，巩固技术又不用花冤枉钱，开展工作的时候也是遇到了不少问题，但是总的来说，收获还是蛮大的，希望以后能继续努力，提升自己。不过，毕竟是应届生，刚开始也没有直接进入项目去参加开发，而是从一些基础的工作开始做起，整理文档占比就比较多，写的最多的文档可能就是帮经理写的招标文档，当然这也是在闲着的时候，后面开始做项目了，相对就少起来了。 言归正传，就第一个项目而言，当时刚开始接触的时候，本身也是好奇得很，加上当时我在组里也算是能力稍好的，组长大哥也是把重构代码中那一块难啃的骨头分给了我，就这么折腾了好几个月，也算是初见成效，但是唯有组长的一句话【凑活弄就行】，也算是给后面我去南京出差埋了个大坑。当时项目重构差不多了之后，在和平门那里的国家电网的办公楼里进行调试，虽然办公环境没的说，就是电脑太老了，导出sql文件都能卡死你一天都不是吹牛逼的，而且我们四五个人就给分了一台来调试，经过了一个多月的调试吧（好像是），也算是大功告成了（其实并没有，都是自以为的），直到最后拷贝源代码的时候出错了，拷的不是最新的，但是后面明明都知道了搞错了，也没有及时去再拷贝一份，直到人家换机器了，代码不知所踪。 再后来就是着手做第二个项目了，出差好像就是在这一段时间，当时公司组织去北戴河团建的，然后就出发前两天通知我去南京出差，去那边调试之前改的电网的项目，寻思着公费旅游也就答应了，但是基于之前代码没拷贝新的，跟组长大哥沟通的是去那边改，也不知道项目经理知不知道这事儿，也是无所谓了，去就去呗，到南京的当天下午我就去了（大哥说可以第二天在去，我笑了，我真积极），原定是出差两个星期的，在这边就感觉跟我们公司差好多，单论项目组里的人员架构就差好多，我们组里算是一个将军带几个新兵的感觉，没人家的有战斗力感觉，但是也算是开眼界了，见识了微服务的冰山一角，没去啥地方玩儿也就去长江边上走了走，但是这屎山代码我改了将近一个月吧好像，就是之前大哥说的【凑活弄就行】，这帮同届基本上就只改代码也不测试，而且也不懂业务，每次人家测试问我业务我都一脸懵，只能给大哥打电话求助，我改的头皮发麻，才勉强能给人家测试，还有这段时间我在这边测试组长-我-我项目经理中间当传声筒，我就纳闷了，你们不是都在群里么，每次都要我来回打电话，回北京之后也是到休了两天（这里就有点不愉快了，我加班加点赶进度，经理还不愿意给我倒休，最后折中到休了两天，出差补贴还给打折了，这时候我就萌生了离职的念头了），后面去医院检查了一下，颈椎有些毛病，而且群里通知还要去那边出差，趁着这个机会我也很快的离职了，也算是感谢经理给我特批了。后面组长大哥也是开玩笑的一语道破我跑路了。后面同届交接我的同事代替我去出差了，回来人也离职跑路了。 接着是第二个项目，开始也是初步过了一下，组长大哥搭起来框架环境就开始干了，这个项目主要是工作流oa这一块，大哥给搭好的，主要是要看懂怎么用，包括页面、代码这一块，因为我主要是写微信小程序这一块，除了基本的增删改，对接这个工作流是主要的工作，仔细看下来也不算难，对接上了，效果还是不错的，期间主要是将微信开发者工具换成了HBuilderX，用vue写代码换成微信小程序的代码去执行。后面这个项目也就停止了，应该是不赚钱了，就结束了。 总结下来，感觉这一年收获还是蛮大的，但是也遇到了不少问题，也算是接受了一波社会的毒打，希望以后能继续努力，提升自己。 .indent { text-indent: 2em; line-height: 1.75; font-size: 16px; }","categories":[{"name":"其他","slug":"other","permalink":"http://example.com/categories/other/"}],"tags":[]},{"title":"工作总结","slug":"北京亚大通讯/index","date":"2025-06-28T02:19:57.000Z","updated":"2025-08-25T11:57:58.617Z","comments":true,"path":"2025/06/28/北京亚大通讯/index/","permalink":"http://example.com/2025/06/28/%E5%8C%97%E4%BA%AC%E4%BA%9A%E5%A4%A7%E9%80%9A%E8%AE%AF/index/","excerpt":"","text":"var ap = new APlayer({ element: document.getElementById(\"aplayer-kAbqTxSj\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"Radio (Dum-Dum)\", author: \"宋雨琦 (YUQI)\", url: \"/music/宋雨琦-_YUQI_-Radio-_Dum-Dum__L.mp3\", pic: \"/music/T002R300x300M0000032oAnT063teb_1.png\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap);","categories":[{"name":"其他","slug":"other","permalink":"http://example.com/categories/other/"}],"tags":[]}],"categories":[{"name":"问题记录","slug":"problems","permalink":"http://example.com/categories/problems/"},{"name":"技术","slug":"technology","permalink":"http://example.com/categories/technology/"},{"name":"其他","slug":"other","permalink":"http://example.com/categories/other/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"Scala","slug":"Scala","permalink":"http://example.com/tags/Scala/"},{"name":"Docker","slug":"Docker","permalink":"http://example.com/tags/Docker/"}]}