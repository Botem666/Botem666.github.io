{"meta":{"title":"Botem的博客","subtitle":{"enable":false,"effect":true,"typed_option":null,"source":false,"sub":["慢慢走，沿途有风景，背后有阳光。","愿你我都能活得坦荡而深情。","生活不是活过的日子，而是记住的日子。","这里，是我舍不得忘记的时光。"]},"description":"一个热爱编程与写作的博客","author":"Botem","url":"http://example.com","root":"/"},"pages":[{"title":"分类","date":"2025-08-09T07:07:43.190Z","updated":"2025-08-09T07:07:43.190Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2025-08-23T04:47:16.744Z","updated":"2025-08-23T04:47:16.744Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"var ap = new APlayer({ element: document.getElementById(\"aplayer-aGxMfZfz\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"Radio (Dum-Dum)\", author: \"宋雨琦 (YUQI)\", url: \"/music/宋雨琦-_YUQI_-Radio-_Dum-Dum__L.mp3\", pic: \"/music/T002R300x300M0000032oAnT063teb_1.png\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap);"},{"title":"link","date":"2025-08-09T03:00:06.000Z","updated":"2025-08-09T03:00:15.515Z","comments":true,"path":"link/index.html","permalink":"http://example.com/link/index.html","excerpt":"","text":""},{"title":"标签","date":"2025-08-09T07:07:55.885Z","updated":"2025-08-09T07:07:55.885Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"YAML配置中Boolean类型参数赋值失效问题解析","slug":"20250825/index","date":"2025-08-25T11:24:29.000Z","updated":"2025-08-25T12:13:03.215Z","comments":true,"path":"2025/08/25/20250825/index/","permalink":"http://example.com/2025/08/25/20250825/index/","excerpt":"","text":"var ap = new APlayer({ element: document.getElementById(\"aplayer-mXuYPfKz\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"Radio (Dum-Dum)\", author: \"宋雨琦 (YUQI)\", url: \"/music/宋雨琦-_YUQI_-Radio-_Dum-Dum__L.mp3\", pic: \"/music/T002R300x300M0000032oAnT063teb_1.png\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); YAML配置中Boolean类型参数赋值失效问题解析基于@Data注解与IDEA自动生成的Setter&#x2F;Getter方法差异问题背景介绍•Spring Boot项目中YAML配置文件的基本使用•Lombok的@Data注解及其在简化代码中的作用•IDEA集成开发环境自动生成setter&#x2F;getter方法的方式 Boolean类型参数处理难点•Java类中定义Boolean类型属性的例子 123public class ExampleConfig &#123; private Boolean isEnabled;&#125; •@Data注解下Boolean属性默认生成的getter&#x2F;setter形式对比 123// @Data 自动生成public Boolean getIsEnabled() &#123; ... &#125;public void setIsEnabled(Boolean isEnabled) &#123; ... &#125; •IDEA针对boolean类型字段生成getter&#x2F;setter方法的不同之处展示 123// IDEA 自动生成public boolean isEnabled() &#123; ... &#125;public void setEnabled(boolean enabled) &#123; ... &#125; 问题产生原因分析•解释为何两种方式生成的方法名会导致YAML参数赋值失败 12example: isEnabled: true # 配置示例，但无法正确映射 •具体说明这种冲突如何影响了Spring Boot自动装配机制•通过实际案例演示赋值失败的情况 解决方案探讨•展示如何调整代码以确保兼容性，例如修改属性名 1private Boolean enabled; // 修改为小写开头避免命名冲突 •提供一个完整的解决方案，包括更新后的YAML配置和相应的Java代码段 12example: enabled: true # 更新后的配置 •利用其他Lombok注解如@Getter @Setter来定制化生成的getter&#x2F;setter方法 总结与预防措施•总结导致Boolean类型参数YAML赋值失败的关键因素•提出预防类似问题发生的有效策略，比如遵循一致的命名约定•强调在团队协作环境中保持编码风格统一的重要性，并给出建议","categories":[{"name":"问题记录","slug":"problems","permalink":"http://example.com/categories/problems/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Scala与Java转换遇到的问题","slug":"20250807/index","date":"2025-08-07T11:25:13.000Z","updated":"2025-08-25T12:15:11.633Z","comments":true,"path":"2025/08/07/20250807/index/","permalink":"http://example.com/2025/08/07/20250807/index/","excerpt":"","text":"var ap = new APlayer({ element: document.getElementById(\"aplayer-ksAMntaj\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"Radio (Dum-Dum)\", author: \"宋雨琦 (YUQI)\", url: \"/music/宋雨琦-_YUQI_-Radio-_Dum-Dum__L.mp3\", pic: \"/music/T002R300x300M0000032oAnT063teb_1.png\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); Scala与Java转换遇到的问题在 Scala 中，slice 和 takeRight 方法用于从集合（如 List, Seq, Array 等）中提取子集。当涉及到索引溢出或边界情况时，这两个方法都有各自的行为来确保不会抛出异常。 1. slice 方法slice 方法允许你通过指定的起始和结束索引来获取集合的一个子集。其定义如下： 1def slice(from: Int, until: Int): Seq[A] 参数： from: 开始索引（包含）。 until: 结束索引（不包含）。 行为： 如果 from 或 until 超出了集合的界限，Scala 会自动将它们调整到合法范围内： 如果 from 小于0，则它会被视为0。 如果 until 大于集合的长度，则它会被视为集合的长度。 这意味着即使提供的索引超出了实际范围，也不会导致运行时错误，而是返回尽可能多的数据。 示例： 123val list = List(1, 2, 3, 4, 5)println(list.slice(1, 10)) // 输出: List(2, 3, 4, 5)println(list.slice(-2, 3)) // 输出: List(1, 2, 3) 2. takeRight 方法takeRight 方法用于从集合末尾开始获取指定数量的元素。其定义如下： 1def takeRight(n: Int): Seq[A] 参数： n: 想要获取的元素数量。 行为： 如果 n 大于集合的大小，那么整个集合将会被返回。 如果 n 是负数或者集合为空，则返回空序列。 这种设计使得在处理不确定大小的集合时更加安全，避免了索引越界异常。 示例： 1234val list = List(1, 2, 3, 4, 5)println(list.takeRight(3)) // 输出: List(3, 4, 5)println(list.takeRight(10)) // 输出: List(1, 2, 3, 4, 5)println(list.takeRight(-2)) // 输出: List() 总结无论是 slice 还是 takeRight，Scala 都提供了安全处理超出索引范围的情况的方式，而不会导致程序抛出异常。这种设计有助于编写更健壮、错误更少的代码。对于 slice，它会根据输入的索引自动调整到合法范围；而对于 takeRight，如果请求的数量超过了集合的实际大小，则简单地返回整个集合。","categories":[{"name":"问题记录","slug":"problems","permalink":"http://example.com/categories/problems/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"Scala","slug":"Scala","permalink":"http://example.com/tags/Scala/"}]},{"title":"JVM笔记","slug":"JVM/index","date":"2025-08-07T11:25:13.000Z","updated":"2025-08-25T11:58:17.022Z","comments":true,"path":"2025/08/07/JVM/index/","permalink":"http://example.com/2025/08/07/JVM/index/","excerpt":"","text":"var ap = new APlayer({ element: document.getElementById(\"aplayer-ChjWypBH\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"Radio (Dum-Dum)\", author: \"宋雨琦 (YUQI)\", url: \"/music/宋雨琦-_YUQI_-Radio-_Dum-Dum__L.mp3\", pic: \"/music/T002R300x300M0000032oAnT063teb_1.png\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); JVM定义：Java Virtual Machine - java程序的运行环境（java二进制字节码的运行环境） 好处： 一次编写，到处运行 自动内存管理，垃圾回收功能 数组下标越界检查 多态 比较： 结构： 内存结构程序计数器Program Counter Register 程序计数器（寄存器） java程序计数器以pc寄存器实现 jvm指令执行流程：jvm指令-&gt;解释器（-&gt;程序计数器）-&gt;机器码-&gt;cpu 程序计数器作用：记录吓一跳条vm指令的执行地址 特点： 线程私有 不会存在内存溢出 虚拟机栈Java Virtual Machine Stacks -java 虚拟机栈 栈-线程运行需要的内存空间 栈帧（参数，局部变量，返回地址）-每个方法运行是需要的内存 每个线程运行时需要的内存，称为虚拟机栈 每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存 每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法 问题： 垃圾回收是否涉及占内存？-只回收堆内存 栈内存分配越大越好？-越大反而线程数越少 方法内的局部变量是否线程安全？ 方法内局部变量没有逃离方法的作用访问，线程安全 如果是局部变量引用了对象，并逃离方法的作用方法，需考虑线程安全 内存溢出： 栈帧过多导致栈内存溢出 栈帧过大导致溢出 线程诊断案例： cpu占用高 （linux） 用top命令定位哪个进程占用高 ps H -eo pid,tid,%cpu | grep 进程id （用ps命令进一步定位那个线程占用高） jstack命令 根据线程id找到对应的代码 程序迟迟未响应： jstack命令 +进程id 查看详细信息 本地方法栈为本地方法运行提供存储空间 堆Heap 堆 - 通过new关键字，创建对象都会使用堆内存 特点 线程共享的，队中的对象都需要考虑线程安全问题 有垃圾回收机制 内存溢出 报错：java heap space 暴露问题：改 vm options 如-Xmx 8m 内存诊断 jsp命令 -查看当前系统有哪些java进程 jmap命令 -查看堆内存占用情况（jmap -heap 进程id） jconsloe -图形界面，多功能监测工具，可连续监测 案例：垃圾回收之后，内存占用依旧很高 jvirsualvm工具，heap dump 堆转储 查看快照，排查内存占用最大的对象 方法区 内存溢出 1.8之前会导致永久代内存溢出 报错：PermGen space 演示暴露：-XX：MaxPermSize=8m 1.8之后会导致云空间内存溢出 报错：Meatspace 演示暴露：-XX：MaxMetaspaceSize=8m 常量池 就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息 运行时常量池 常量池是*.class 文件中的，当该类被加载，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址 Stringtable 特性 常量池中的字符串仅是符号，第一次用到时才变为对象 利用串池的机制，来避免重复创建字符串对象 字符串变量拼接的原理是 StringBuilder (1.8) 字符串常量拼接的原理是编译期优化 存在垃圾回收 可以使用 intern 方法，主动将串池中还没有的字符串对象放入串池 1.8 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则放入串池，会把串池中的对象返回 1.6 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有会把此对象复制一份，放入串会把串池中的对象返回池 Stringtable 调优 调整-xx:StringTableSize&#x3D;桶个数 考虑将字符串对象是否入池 直接内存Direct Memory 常见于 NIO 操作时，用于数据缓冲区 分配回收成本较高，但读写性能高 不受JVM 内存回收管理 内存溢出：ava.lang.OutOfMemoryError: Direct buffer memory 回收和分配 使用了Unsafe 对象完成直接内存的分配回收，并且回收需要主动调用 freeMemory 方法 ByteBuffer 的实现类内部，使用了 Cleaner (虚引用)来监测 ByteBuffer 对象，一旦 ByteBuffer 对象被垃圾回收，那么就会由 ReferenceHandler 线程通过 Cleaner 的clean方法调用 ireeMemory 来释放直接内存 -XX:+DisableExplicitGC 现实的禁用gc回收，会导致直接内存的回收，所以用unsafe的freeMenmory方法手动回收 垃圾回收如何判断对象可以回收 引用计数法 可达性分析算法 Java 虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象 扫描堆中的对象，看是否能够沿着GC Root对象 为起点的引用链找到该对象，找不到，表示可以回收 哪些对象可以作为 GC Root ? 四种引用（强引用，弱引用，软引用，虚引用，终结器引用） 1.强引用 -只有所有 GC Roots 对象都不过[强引用]引用该对象，该对象才能被垃圾回收 2.软引用(SoftReference)-仅有软引用引用该对象时，在垃圾回收后，内存仍不足时会再次出发垃圾回收，回收软引用对象-可以配合引用队列来释放软引用自身 3.弱引用(WeakReference)-仅有弱引用引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用对象-可以配合引用队列来释放弱引用自身 4.虚引用(PhantomReference-必须配合引用队列使用，主要配合 BvteBuffer 使用，被引用对象回收时，会将虚引用入队，由Reference Handler 线程调用虚引用相关方法释放直接内存 5.终结器引用 (FinalReference)-无需手动编码，但其内部配合引用队列使用，在垃圾回收时，终结器引用入队 (被引用对象暂时没有被回收)，再由 Finalizer 线程通过终结器引用找到被引用对象并调用它的 finalize 方法，第二次 GC时才能回收被引用对象 垃圾回收算法 标记清除-速度快，有内存碎片 标记整理-速度慢，没有内存碎片 复制-没有内存碎片，需要占用双倍空间 分代垃圾回收 相关参数 垃圾回收器 串行 单线程 堆内存小，适合个人电脑 配置开关: -XX:+UseSerialGC&#x3D;Serial+SerialOld Serial应用复制算法，SerialOld应用在老年代使用标记整理算法 吞吐量优先 多线程 堆内存大，多核cpu 让单位时间内，stw的时间最短（多食少餐） 配置开关： -XX:+UseParallelGC~ -XX:+UseParallel0ldGC (老年代\\标记整理算法) -&gt;（1.8前者默认开启）（其中一个开启都会连带另一个开启） （并行运行） -XX:+UseAdaptiveSizePolicy -&gt;（新生代自适应大小）-XX:GCTimeRatio&#x3D;ratio -&gt;（达成目标，公式为1&#x2F;(1+ratio)，默认ratio&#x3D;99，建议ratio为19）-XX:MaxGCPauseMillis&#x3D;ms -&gt;（达成目标，默认200ms）-XX:ParallelGCThreads&#x3D;n -&gt;（并行线程数） 响应时间优先 多线程 堆内存大，多核cpu 极可能让单次stw的时间最短（少食多餐） 配置开关： -XX:+UseConcMarkSweepGC~ -XX:+UseParNewGC~ Serial0ld （前者cms并发标记清除，老年代）（后者新生代，复制算法）（cms并发失败转为Serial0ld 补救） -XX:ParallelGCThreads&#x3D;n ~ -XX:ConcGCThreads&#x3D;threads （前者并行线程数，后者并发线程数）（后者建议是前者的1&#x2F;4）-XX:CMSInitiatingOccupancyFraction&#x3D;percent （设置执行回收时的内存占比）-XX:+CMSScavengeBeforeRemark （重新标记前新生代垃圾回收开关）（+开启，-关闭） G1 G1垃圾回收阶段 Young Collection E伊甸园，S幸存区，O老年代 Young Collection+CM Mixed Collection Full GC Young Collection跨代引用 新生代回收的跨代引用 (老年代引用新生代) 问题 老年代维护card table（卡表），新生代维护remember set （涉及到引用标记为脏卡） Remark 三色标记法，黑色（存活），灰色（处理中），白色（未处理或垃圾） jdk 8u20字符串去重 jdk 8u40并发标记类卸载 jdk 8u60回收巨型对象 jdk9 并发标记起始时间调整 jdk9 更高效的回收 垃圾回收调优 调优领域 内存 锁竞争 cpu占用 io 确定目标 低延迟or高吞吐量，选择合适的回收器 CMS，G1，ZGC ParallelGC Zing 最快的GC不是发生GC 新生代调优 幸存区大到能保留[当前活跃对象+需要晋升对象] 晋升闻值配置得当，让长时间存活对象尽快晋升 老年代调优 案例","categories":[{"name":"技术","slug":"technology","permalink":"http://example.com/categories/technology/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"springboot配置文件参数配置问题","slug":"20250805/index","date":"2025-08-05T11:25:13.000Z","updated":"2025-08-25T12:15:09.242Z","comments":true,"path":"2025/08/05/20250805/index/","permalink":"http://example.com/2025/08/05/20250805/index/","excerpt":"","text":"var ap = new APlayer({ element: document.getElementById(\"aplayer-ldFkEUdH\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"Radio (Dum-Dum)\", author: \"宋雨琦 (YUQI)\", url: \"/music/宋雨琦-_YUQI_-Radio-_Dum-Dum__L.mp3\", pic: \"/music/T002R300x300M0000032oAnT063teb_1.png\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); springboot配置文件参数配置问题在Spring Boot中，如果你想将YAML配置文件中的参数值注入到注解的参数中，这是一个比较特殊的需求。因为注解本身是编译时处理的，而YAML配置是在运行时加载的，所以不能直接在注解声明时使用YAML中的值。 不过，有几种变通的方法可以实现类似的效果： ✅ 方法一：使用 @Value + SpEL（推荐）虽然你说“非@value”，但这是最常见和标准的方式。如果你愿意接受 @Value，可以这样用： 123@SomeAnnotation(param = &quot;$&#123;your.yaml.key:defaultValue&#125;&quot;)public class YourClass &#123;&#125; 但是注意：这种方式不适用于所有注解，只有那些支持SpEL表达式的框架（如Spring的@Scheduled, @Cacheable等）才有效。 例如： 123@Scheduled(cron = &quot;$&#123;task.cron:0 0 * * * ?&#125;&quot;)public void scheduledTask() &#123;&#125; ✅ 支持这种写法的前提是：该注解被Spring的SpEL解析器处理。 ❌ 为什么不能直接在自定义注解中注入YAML？Java注解的属性必须是编译时常量（compile-time constants），而YAML配置是运行时加载的，因此你不能像这样写： 123// 错误示例！@MyAnnotation(value = &quot;$&#123;app.name&#125;&quot;) // 编译错误或字符串字面量，不会解析public class MyClass &#123;&#125; 这只会把字符串 &quot;$&#123;app.name&#125;&quot; 当作字面量，而不是YAML中的值。 ✅ 正确替代方案：使用 @ConfigurationProperties + 业务逻辑判断如果你希望某个注解的行为依赖于YAML配置，最佳实践是： 定义一个配置类读取YAML 在运行时通过AOP或条件判断读取该配置，结合注解行为 示例：1. YAML配置 12app: feature-enabled: true 2. 配置类 1234567891011121314@Component@ConfigurationProperties(prefix = &quot;app&quot;)public class AppProperties &#123; private boolean featureEnabled = false; // getter and setter public boolean isFeatureEnabled() &#123; return featureEnabled; &#125; public void setFeatureEnabled(boolean featureEnabled) &#123; this.featureEnabled = featureEnabled; &#125;&#125; 3. 自定义注解 1234@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface ConditionalFeature &#123;&#125; 4. AOP切面处理（运行时结合YAML） 12345678910111213141516@Aspect@Componentpublic class FeatureAspect &#123; @Autowired private AppProperties appProperties; @Around(&quot;@annotation(ConditionalFeature)&quot;) public Object checkFeature(ProceedingJoinPoint joinPoint) throws Throwable &#123; if (!appProperties.isFeatureEnabled()) &#123; System.out.println(&quot;Feature is disabled by YAML config.&quot;); return null; &#125; return joinPoint.proceed(); &#125;&#125; 5. 使用 1234@ConditionalFeaturepublic void businessMethod() &#123; System.out.println(&quot;Executing business logic...&quot;);&#125; ✅ 方法三：使用 Environment 在运行时读取你也可以在代码中通过 Environment 获取YAML值，然后决定是否执行某段逻辑： 1234567@Autowiredprivate Environment env;public void someMethod() &#123; String value = env.getProperty(&quot;your.yaml.key&quot;, &quot;default&quot;); // 根据 value 做逻辑判断&#125; 总结 方法 是否可行 说明 @Value(&quot;$&#123;key&#125;&quot;) 在注解中 ⚠️ 有限支持 仅Spring内置支持SpEL的注解可用 直接在自定义注解写 $&#123;&#125; ❌ 不可行 注解属性必须是常量 @ConfigurationProperties + AOP&#x2F;逻辑控制 ✅ 推荐 最灵活、最符合Spring设计 Environment 运行时读取 ✅ 可行 适合动态判断 结论 你不能直接将YAML参数注入到注解的参数中，但可以通过 @ConfigurationProperties 或 Environment 在运行时读取配置，再结合AOP、条件判断等方式实现“基于YAML配置控制注解行为”的效果。 如果你能提供具体的使用场景（比如你想控制缓存、定时任务、权限等），我可以给出更精准的解决方案。","categories":[{"name":"问题记录","slug":"problems","permalink":"http://example.com/categories/problems/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Docker","slug":"Docker/index","date":"2025-07-02T11:25:13.000Z","updated":"2025-08-25T11:58:12.120Z","comments":true,"path":"2025/07/02/Docker/index/","permalink":"http://example.com/2025/07/02/Docker/index/","excerpt":"","text":"var ap = new APlayer({ element: document.getElementById(\"aplayer-OVruPcQp\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"Radio (Dum-Dum)\", author: \"宋雨琦 (YUQI)\", url: \"/music/宋雨琦-_YUQI_-Radio-_Dum-Dum__L.mp3\", pic: \"/music/T002R300x300M0000032oAnT063teb_1.png\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 安装docker123456789101112131415161718192021222324252627282930313233#更新yum包yum update #删除旧版本yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine #安装需要的工具yum install -y yum-utils#配置源yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo #安装yum install docker-ce docker-ce-cli containerd.io#启动服务systemctl start docker#测试docker run hello-world#设置开机启动systemctl enable docker.service 安装 docker compose12345678#git 拉取 docker compose curl -L &quot;https://github.com/docker/compose/releases/download/1.28.2/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose#授权chmod +x /usr/local/bin/docker-compose#建立软连接ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose 目录1234567891011121314151617├── app //存放项目│ ├── dist| ├── Dockerfile│ └── funds-admin.jar├── compose //用于定义docker compose 项目| └──docker-compose.yml├── mysql //mysql配置及数据内容│ ├── conf│ ├── data│ └── logs├── nginx //nginx配置及数据内容│ ├── conf│ └── logs└── redis //redis配置及数据内容 ├── data └── redis.conf 拉取镜像12345678#mysql 镜像docker pull mysql:8.0.20#redis 镜像docker pull redis#nignx 镜像docker pull nignx redis.conf1234567891011121314#注释掉这部分，这是限制redis只能本地访问#bind 127.0.0.1#默认yes，开启保护模式，限制为本地访问protected-mode no#默认no，意为是否以守护进程方式启动，可后台运行，不要改为yes 否则可能redis会启动失败daemonize no#redis持久化(可选)appendonly yes#设置redis密码#requirepass $REDIS_DEFAULT_PASS nginx.conf123456789101112131415161718192021222324252627282930313233#user root；worker_processes 1;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; server &#123; listen 80; server_name localhost; location / &#123; root /usr/share/nginx/html; try_files $uri $uri/ /index.html last; index index.html index.htm; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125;&#125; Dockerfile12345FROM openjdk:8-jdk-alpineVOLUME /tmpADD funds-admin.jar app.jarENTRYPOINT [&quot;java&quot;,&quot;-Djava.security.egd=file:/dev/./urandom&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;] 12#制作dockerfile镜像docker build -t docker-test . docker-compose.yml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869version: &quot;3&quot;services: redis: image: redis:latest restart: always container_name: funds_redis volumes: - ../redis/redis.conf:/etc/redis/redis.conf:ro - ../redis/data:/data command: - redis-server - /etc/redis/redis.conf ports: - 6379:6379 networks: - appnet mysql: image: mysql:8.0.20 restart: always container_name: funds_mysql volumes: - ../mysql/conf:/etc/mysql/conf.d - ../mysql/data:/var/lib/mysql - ../mysql/logs:/var/log environment: MYSQL_ROOT_PASSWORD: 123456 ports: - 3306:3306 networks: - appnet command: #不区分大小写 --lower_case_table_names=1 nginx: image: nginx # 镜像名称 restart: always container_name: nginx # 容器名字 restart: always # 开机自动重启 ports: # 端口号绑定（宿主机:容器内） - 80:80 volumes: # 目录映射（宿主机:容器内） - ../app/dist:/usr/share/nginx/html - ../nginx/conf/nginx.conf:/etc/nginx/nginx.conf privileged: true # 这个必须要，解决nginx的文件调用的权限问题 networks: - appnet webapp: build: ../app restart: always container_name: funds_sys depends_on: - mysql - redis - nginx ports: - &quot;8888:8888&quot; networks: - appnetnetworks: appnet: driver: bridge 1234#启动项目docker-compose -p appweb -f ./compose/docker-compose.yml up -d#停止项目docker-compose -p appweb -f ./compose/docker-compose.yml down --rmi all 数据库远程连接数据库写入数据","categories":[{"name":"技术","slug":"technology","permalink":"http://example.com/categories/technology/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://example.com/tags/Docker/"}]},{"title":"工作总结","slug":"北京亚大通讯/index","date":"2025-06-28T02:19:57.000Z","updated":"2025-08-25T11:57:58.617Z","comments":true,"path":"2025/06/28/北京亚大通讯/index/","permalink":"http://example.com/2025/06/28/%E5%8C%97%E4%BA%AC%E4%BA%9A%E5%A4%A7%E9%80%9A%E8%AE%AF/index/","excerpt":"","text":"var ap = new APlayer({ element: document.getElementById(\"aplayer-tFbgUnPw\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"Radio (Dum-Dum)\", author: \"宋雨琦 (YUQI)\", url: \"/music/宋雨琦-_YUQI_-Radio-_Dum-Dum__L.mp3\", pic: \"/music/T002R300x300M0000032oAnT063teb_1.png\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap);","categories":[{"name":"其他","slug":"other","permalink":"http://example.com/categories/other/"}],"tags":[]},{"title":"工作总结","slug":"北京南天软件/index","date":"2025-06-28T02:19:57.000Z","updated":"2025-08-25T11:58:05.248Z","comments":true,"path":"2025/06/28/北京南天软件/index/","permalink":"http://example.com/2025/06/28/%E5%8C%97%E4%BA%AC%E5%8D%97%E5%A4%A9%E8%BD%AF%E4%BB%B6/index/","excerpt":"","text":"var ap = new APlayer({ element: document.getElementById(\"aplayer-wBlhswCz\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"Radio (Dum-Dum)\", author: \"宋雨琦 (YUQI)\", url: \"/music/宋雨琦-_YUQI_-Radio-_Dum-Dum__L.mp3\", pic: \"/music/T002R300x300M0000032oAnT063teb_1.png\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 总结 回想这一年感觉也算是波澜起伏了，应届生初入职场，对一切也算是好奇得很，但是同届应届生的水平也是参差不齐的，有时候还得帮人家忙，真是庆幸毕设自己一点一点敲出来的，巩固技术又不用花冤枉钱，开展工作的时候也是遇到了不少问题，但是总的来说，收获还是蛮大的，希望以后能继续努力，提升自己。不过，毕竟是应届生，刚开始也没有直接进入项目去参加开发，而是从一些基础的工作开始做起，整理文档占比就比较多，写的最多的文档可能就是帮经理写的招标文档，当然这也是在闲着的时候，后面开始做项目了，相对就少起来了。 言归正传，就第一个项目而言，当时刚开始接触的时候，本身也是好奇得很，加上当时我在组里也算是能力稍好的，组长大哥也是把重构代码中那一块难啃的骨头分给了我，就这么折腾了好几个月，也算是初见成效，但是唯有组长的一句话【凑活弄就行】，也算是给后面我去南京出差埋了个大坑。当时项目重构差不多了之后，在和平门那里的国家电网的办公楼里进行调试，虽然办公环境没的说，就是电脑太老了，导出sql文件都能卡死你一天都不是吹牛逼的，而且我们四五个人就给分了一台来调试，经过了一个多月的调试吧（好像是），也算是大功告成了（其实并没有，都是自以为的），直到最后拷贝源代码的时候出错了，拷的不是最新的，但是后面明明都知道了搞错了，也没有及时去再拷贝一份，直到人家换机器了，代码不知所踪。 再后来就是着手做第二个项目了，出差好像就是在这一段时间，当时公司组织去北戴河团建的，然后就出发前两天通知我去南京出差，去那边调试之前改的电网的项目，寻思着公费旅游也就答应了，但是基于之前代码没拷贝新的，跟组长大哥沟通的是去那边改，也不知道项目经理知不知道这事儿，也是无所谓了，去就去呗，到南京的当天下午我就去了（大哥说可以第二天在去，我笑了，我真积极），原定是出差两个星期的，在这边就感觉跟我们公司差好多，单论项目组里的人员架构就差好多，我们组里算是一个将军带几个新兵的感觉，没人家的有战斗力感觉，但是也算是开眼界了，见识了微服务的冰山一角，没去啥地方玩儿也就去长江边上走了走，但是这屎山代码我改了将近一个月吧好像，就是之前大哥说的【凑活弄就行】，这帮同届基本上就只改代码也不测试，而且也不懂业务，每次人家测试问我业务我都一脸懵，只能给大哥打电话求助，我改的头皮发麻，才勉强能给人家测试，还有这段时间我在这边测试组长-我-我项目经理中间当传声筒，我就纳闷了，你们不是都在群里么，每次都要我来回打电话，回北京之后也是到休了两天（这里就有点不愉快了，我加班加点赶进度，经理还不愿意给我倒休，最后折中到休了两天，出差补贴还给打折了，这时候我就萌生了离职的念头了），后面去医院检查了一下，颈椎有些毛病，而且群里通知还要去那边出差，趁着这个机会我也很快的离职了，也算是感谢经理给我特批了。后面组长大哥也是开玩笑的一语道破我跑路了。后面同届交接我的同事代替我去出差了，回来人也离职跑路了。 接着是第二个项目，开始也是初步过了一下，组长大哥搭起来框架环境就开始干了，这个项目主要是工作流oa这一块，大哥给搭好的，主要是要看懂怎么用，包括页面、代码这一块，因为我主要是写微信小程序这一块，除了基本的增删改，对接这个工作流是主要的工作，仔细看下来也不算难，对接上了，效果还是不错的，期间主要是将微信开发者工具换成了HBuilderX，用vue写代码换成微信小程序的代码去执行。后面这个项目也就停止了，应该是不赚钱了，就结束了。 总结下来，感觉这一年收获还是蛮大的，但是也遇到了不少问题，也算是接受了一波社会的毒打，希望以后能继续努力，提升自己。 .indent { text-indent: 2em; line-height: 1.75; font-size: 16px; }","categories":[{"name":"其他","slug":"other","permalink":"http://example.com/categories/other/"}],"tags":[]}],"categories":[{"name":"问题记录","slug":"problems","permalink":"http://example.com/categories/problems/"},{"name":"技术","slug":"technology","permalink":"http://example.com/categories/technology/"},{"name":"其他","slug":"other","permalink":"http://example.com/categories/other/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"Scala","slug":"Scala","permalink":"http://example.com/tags/Scala/"},{"name":"Docker","slug":"Docker","permalink":"http://example.com/tags/Docker/"}]}